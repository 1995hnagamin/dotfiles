set number
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab
filetype on
filetype indent on
filetype plugin on
syntax on
set autoindent
set smartindent
set ambiwidth=double
set hlsearch
set clipboard=unnamed,autoselect
set backspace=indent,eol,start
set background=dark
set foldmethod=marker
set t_ut=
set t_Co=256
colorscheme molokai
highlight Normal ctermbg=none

set undodir=$HOME/.vim/undodir
set undofile

function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

" show tabline
function! s:my_tabline()
  let s = ''
  for i in range(1, tabpagenr('$'))
    let bufnrs = tabpagebuflist(i)
    let bufnr = bufnrs[tabpagewinnr(i) - 1]
    let no = i  
    let mod = getbufvar(bufnr, '&modified') ? '!' : ' '
    let title = fnamemodify(bufname(bufnr), ':t')
    let title = title
    let s .= '%'.i.'T'
    let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
    let s .= no . ':' . title
    let s .= mod
    let s .= '%#TabLineFill# '
  endfor
  let s .= '%#TabLineFill#%T%=%#TabLine#'
  return s
endfunction
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2

nnoremap    [Tag]   <Nop>
nmap    , [Tag]
for n in range(1, 9)
  execute 'nnoremap <silent> [Tag]'.n  ':<C-u>tabnext'.n.'<CR>'
endfor

map <silent> [Tag]c :tablast <bar> tabnew<CR>
map <silent> [Tag]x :tabclose<CR>
map <silent> [Tag]n :tabnext<CR>
map <silent> [Tag]p :tabprevious<CR>

nnoremap <silent> <ESC><ESC> :noh<CR>


"--- Plugin

" auto-save
let g:auto_save = 1
let g:auto_save_in_insert_mode = 0

" Gundo
nnoremap <F5> :GundoToggle<CR>

" lightline
let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ 'active': {
      \   'left': [ ['mode', 'paste'],
      \             ['fugitive', 'readonly'] ]
      \ },
      \ 'component': {
      \   'readonly': '%{&readonly?"ðŸ”’ ":""}',
      \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}'
      \ },
      \ 'component_visible_condition': {
      \   'readonly': '(&filetype!="help"&& &readonly)',
      \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
      \ },
      \ 'separator': { 'left':"",'right':"" },
      \ 'subseparator': { 'left':"",'right':"" },
      \ }

set laststatus=2

" NeoBundle
if has('vim_starting')
  if &compatible
    set nocompatible
  endif

  " Required:
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

" Required:
call neobundle#begin(expand('~/.vim/bundle/'))

  " Required:
  NeoBundleFetch 'Shougo/neobundle.vim'

  " Note: You don't set neobundle setting in .gvimrc!
  NeoBundle 'kchmck/vim-coffee-script'
  NeoBundle 'mattn/sonictemplate-vim'
  NeoBundle 'kana/vim-smartinput'
  NeoBundle 'Shougo/neocomplete.vim'
  NeoBundle 'Shougo/neosnippet.vim'
  NeoBundle 'Shougo/neosnippet-snippets'
  NeoBundle 'Shougo/vimproc.vim', {
        \ 'build': {
        \     'windows': 'tools\\update-dll-mingw',
        \     'cygwin' : 'make -f make_cygwin.mak',
        \     'mac' : 'make -f make_mac.mak',
        \     'linux' : 'make',
        \     'unix' : 'gmake',
        \    },
        \ }
  NeoBundle 'kana/vim-filetype-haskell'
  NeoBundle 'thinca/vim-quickrun'
  NeoBundle 'vim-scripts/vim-auto-save'
  NeoBundle 'itchyny/lightline.vim'
  NeoBundle 'tpope/vim-fugitive'
  NeoBundle 'vim-scripts/YankRing.vim'
  NeoBundle 'osyo-manga/shabadou.vim'
  NeoBundle 'osyo-manga/vim-watchdogs'
  NeoBundle 'lervag/vim-latex'
  NeoBundle 'tpope/vim-surround'
  NeoBundle 'vim-scripts/Gundo'

call neobundle#end()

" Required:
filetype plugin indent on

NeoBundleCheck

" neocomplete
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_ignore_case = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#max_list = 8
let g:neocomplete#min_keyword_length = 3
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns._ = '\h\w*'
inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"

if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.tex = '\\ref{\s*[0-9A-Za-z_:]*'

" neosnippet
" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
"imap <expr><TAB>
" \ pumvisible() ? "\<C-n>" :
" \ neosnippet#expandable_or_jumpable() ?
" \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"


" quickrun.vim
let g:quickrun_config = {
\   "make" : {
\       "command"   : "mingw32-make",
\       "exec" : "%c %o",
\       "outputter" : "error:buffer:quickfix",
\       "runner" : "vimproc",
\       "hook/cd/enable" : 1,
\       "hook/cd/directory" : "D:/test/aaa",
\   },
\}

let g:quickrun_config['tex'] = {
            \   'command' : 'latexmk',
            \   'outputter' : 'error',
            \   'outputter/error/error' : 'quickfix',
            \   'cmdopt': '-pdfdvi',
            \   'exec': ['%c %o %s']
            \ }

" unite.vim
let g:unite_enable_start_insert=1

" watchdogs.vim
call watchdogs#setup(g:quickrun_config)
let g:watchdogs_check_CursorHold_enable = 1

"--- language

" C++
augroup cpp
  au Filetype cpp let g:auto_save = 0
augroup END

" Haskell
augroup vimrc
  au Filetype haskell setlocal shiftwidth=4 tabstop=4 softtabstop=4
augroup END

" PAS, PASXX
augroup vimrc
  au Filetype pasm,pasxx NeoCompleteLock
augroup END


" Scheme
set lispwords=define-module,define,define-macro,define-syntax,syntax-case,syntax-rules,let1,receive,if,cond,lambda,case

